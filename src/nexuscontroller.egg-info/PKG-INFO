Metadata-Version: 2.4
Name: nexuscontroller
Version: 0.1.0
Summary: Gamepad reader and mapping tools with WebSocket server
Author: DavidGCalles
License: MIT
Project-URL: homepage, https://example.invalid/
Description-Content-Type: text/markdown
Requires-Dist: pygame
Requires-Dist: websockets
Requires-Dist: pyserial

# üéÆ ControlNexus ‚Äî Gamepad Abstraction & Examples

ControlNexus normaliza entradas de gamepads y proporciona herramientas para mapear, depurar y exponer los datos por WebSocket o en un paquete binario compactado. Adem√°s incluye ejemplos (entre ellos un demo Canvas llamado CyberMaze).

Este README se actualiza para reflejar la estructura actual del repositorio, las dependencias y los cambios recientes (parametrizaci√≥n del generador de laberintos, dash destructivo, XP diferida, etc.).

## üõ†Ô∏è Requisitos
 - Python 3.10+ (probado con 3.12)
 - Paquetes pip: `pygame`, `websockets`, `pyserial` (si necesitas serial)

Instalaci√≥n r√°pida:
```powershell
python -m pip install --upgrade pip
pip install pygame websockets pyserial
```

## ¬øQu√© hay en este repositorio?
 - `main.py` ‚Äî Servidor asyncio que crea un WebSocket en `ws://localhost:8765` y transmite el JSON normalizado de `InputSource`.
 - `inputSource.py` ‚Äî Lector principal usando `pygame` (headless). Normaliza ejes, aplica baseline/calibraci√≥n y proporciona `to_json()` / `to_bytes()`.
 - `controller_config.json` ‚Äî Archivo generado por los mappers con IDs sem√°nticos de botones/ejes.
 - `mappers/` ‚Äî Herramientas interactivas para mapear mandos:
   - `scientific_mapper.py` ‚Äî calibraci√≥n autom√°tica de baseline y mapeo (recomendado).
   - `robust_mapper.py`, `paranoid_mapper.py` ‚Äî variantes con diferentes heur√≠sticas.
 - `debug/` ‚Äî scripts de depuraci√≥n (raw input sniffer, pygame debug helper).
 - `examples/` ‚Äî demos y utilidades front-end:
   - `examples/cybermaze/` ‚Äî juego Canvas (HTML + JS split en `config.js`, `maze.js`, `entities.js`, `input.js`, `main.js`).
   - `examples/twinStick.html`, `viewer.html` ‚Äî p√°ginas de demostraci√≥n.

## Ejecutar el backend (servidor de input)
1. Conecta tu gamepad y genera `controller_config.json` si no lo tienes:
```powershell
python mappers/scientific_mapper.py
```
Sigue las instrucciones en pantalla; el JSON resultante se guarda en `controller_config.json`.

2. Ejecuta el servidor WebSocket:
```powershell
python main.py
```
Salida esperada:
```
üéÆ Backend Listo. Mando: <NOMBRE>
üì° WebSocket Server en ws://localhost:8765
```

3. Abre cualquier cliente que consuma el JSON (por ejemplo `examples/cybermaze/cyberMaze.html`).

## Formatos de salida

### 1) WebSocket ‚Äî JSON (humano-legible)
 - Frecuencia: ~60Hz
 - Ejes normalizados en [-1.0, 1.0], botones 0/1.
 - Funci√≥n utilitaria: `InputSource.to_json(data)` devuelve la cadena JSON.

Ejemplo (claves principales): `a,b,x,y,lb,rb,back,start,l3,r3,up,down,left,right,lx,ly,rx,ry,lt,rt`

### 2) Fast Path ‚Äî Binario
 - `InputSource.to_bytes(data)` empaqueta 14 bytes: `'<Hhhhhhh'`
 - Mapa de bits (botones) y escala de ejes a `int16` est√° en `inputSource.py`.

## CyberMaze (demo)

Ruta: `examples/cybermaze/`

 - Abrir `examples/cybermaze/cyberMaze.html` en un navegador moderno.
 - Ejecutar el backend (`python main.py`) para alimentar el juego.

Notas importantes del demo:
 - El c√≥digo del demo est√° dividido en archivos dentro del directorio `examples/cybermaze/` para facilitar lectura y mantenimiento: `config.js`, `maze.js`, `entities.js`, `input.js`, `main.js`.
 - Cambios recientes y comportamiento del juego:
   - Parametrizaci√≥n del generador de laberintos (`mazeCorridorWidth`, `mazeBreakableBlockChance`, `mazeCarveSeed`, `mazeCarveSpacing` en `config.js`).
   - Corridors construidos por bloques (carving por bloques) para obtener pasillos consistentes.
   - Dash del jugador es destructivo (`playerDashIsDestructive`) y genera una explosi√≥n al final del dash.
   - Si el Ray (habilidad) est√° desbloqueado y se mantiene RT, el dash mejora (m√°s r√°pido/largo/mas da√±o): "ray-dash".
   - XP por clearing stage: ahora se guarda en `player.pendingXP` y se aplica/procesa al continuar (evita level-ups instant√°neos durante el overlay). Esto se puede ajustar en `config.js` con `xpPerStage`.

## Configuraci√≥n destacada (editar `examples/cybermaze/config.js`)
 - `mazeCorridorWidth` (int): ancho del pasillo en tiles (recomendado 2).
 - `mazeBreakableBlockChance` (0..1): probabilidad de que un bloque de muro sea destruible.
 - `mazeCarveSeed` (null|int): semilla para generar laberintos reproducibles.
 - `mazeCarveSpacing` (null|int): paso de carving (por defecto `mazeCorridorWidth * 2`).
 - `xpPerStage` (int): XP entregado al completar una escena (ahora diferido a `player.pendingXP`).

## Desarrollo y notas internas
 - `inputSource.py` aplica baseline/rest correction a ejes seg√∫n `controller_config.json` para evitar problemas con gatillos que reportan -1.0 en reposo.
 - Los mappers en `mappers/` ayudan a crear `controller_config.json` con distintos niveles de robustez.
 - Si habilitas `mazeCarveSeed`, la intenci√≥n es usar un PRNG determinista. Actualmente el c√≥digo usa `Math.random()` ‚Äî puedo reemplazarlo por un PRNG basado en semilla si quieres reproducibilidad exacta.

## Troubleshooting r√°pido
 - Si no detecta el mando: cierra Steam, instala drivers oficiales y ejecuta los mappers.
 - Si los gatillos tienen offset: vuelve a correr `mappers/scientific_mapper.py`.
 - Si el demo no conecta: aseg√∫rate de que `python main.py` est√© corriendo y escucha en `ws://localhost:8765`.
